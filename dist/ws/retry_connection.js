"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RetryConnection=void 0,require("core-js/modules/web.dom-collections.iterator.js");var _index=require("../utils/logger/index.js"),_observable_connection=require("./observable_connection.js");function _classPrivateMethodInitSpec(a,b){_checkPrivateRedeclaration(a,b),b.add(a)}function _classPrivateFieldInitSpec(a,b,c){_checkPrivateRedeclaration(a,b),b.set(a,c)}function _checkPrivateRedeclaration(a,b){if(b.has(a))throw new TypeError("Cannot initialize the same private elements twice on an object")}function _classPrivateMethodGet(a,b,c){if(!b.has(a))throw new TypeError("attempted to get private field on non-instance");return c}function _classPrivateFieldGet(a,b){var c=_classExtractFieldDescriptor(a,b,"get");return _classApplyDescriptorGet(a,c)}function _classApplyDescriptorGet(a,b){return b.get?b.get.call(a):b.value}function _classPrivateFieldSet(a,b,c){var d=_classExtractFieldDescriptor(a,b,"set");return _classApplyDescriptorSet(a,d,c),c}function _classExtractFieldDescriptor(a,b,c){if(!b.has(a))throw new TypeError("attempted to "+c+" private field on non-instance");return b.get(a)}function _classApplyDescriptorSet(a,b,c){if(b.set)b.set.call(a,c);else{if(!b.writable)throw new TypeError("attempted to set read only private field");b.value=c}}var _started=/*#__PURE__*/new WeakMap,_reconnect=/*#__PURE__*/new WeakSet;class RetryConnection extends _observable_connection.ObservableConnection{constructor(a){let b=1<arguments.length&&arguments[1]!==void 0?arguments[1]:10,c=2<arguments.length&&arguments[2]!==void 0?arguments[2]:500,d=3<arguments.length&&arguments[3]!==void 0?arguments[3]:32e3;super(a),_classPrivateMethodInitSpec(this,_reconnect),_classPrivateFieldInitSpec(this,_started,{writable:!0,value:void 0}),this.maxRetryCount=b,this.minRetryIntervalMs=c,this.maxRetryIntervalMs=d,this.retryCount=0,this.retryIntervalMs=c,this.lastConnectionTime=Date.now()-d,this.retryTimer=null,_classPrivateFieldSet(this,_started,!1)}start(){this.isStarted()||(_index.logger.info("".concat(this.getName(),": starting...")),_classPrivateFieldSet(this,_started,!0),this.connect())}stop(){_index.logger.info("".concat(this.getName(),": stopping...")),_classPrivateFieldSet(this,_started,!1),this.disconnect()}isStarted(){return _classPrivateFieldGet(this,_started)}onDisconnected(){super.onDisconnected(),this.isStarted()&&_classPrivateMethodGet(this,_reconnect,_reconnect2).call(this)}connect(){this.isStarted()&&super.connect()}disconnect(){this.retryTimer&&(clearTimeout(this.retryTimer),this.retryTimer=null),super.disconnect()}onErrorMessage(a,b){super.onErrorMessage(a,b),this.stop()}}exports.RetryConnection=RetryConnection;function _reconnect2(){let a=this;return Date.now()-this.lastConnectionTime<this.retryIntervalMs?(this.retryIntervalMs=Math.min(2*this.retryIntervalMs,this.maxRetryIntervalMs),++this.retryCount):(this.retryCount=1,this.retryIntervalMs=this.minRetryIntervalMs),this.retryCount>=this.maxRetryCount?void this.stop():void(this.retryTimer=setTimeout(()=>{_index.logger.info("".concat(this.getName(),": retrying connection... [interval: ").concat(this.retryIntervalMs,"ms]")),a.lastConnectionTime=Date.now()+4e3,a.connect()},this.retryIntervalMs))}